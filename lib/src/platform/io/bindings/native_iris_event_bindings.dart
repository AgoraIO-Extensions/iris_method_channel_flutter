// ignore_for_file: camel_case_types, non_constant_identifier_names, public_member_api_docs, sort_constructors_first

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

import 'package:ffi/ffi.dart';

import '../../../collect_stack.dart';

/// Bindings to IrisEventHandler
class NativeIrisEventBinding {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeIrisEventBinding(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeIrisEventBinding.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  int InitDartApiDL(
    ffi.Pointer<ffi.Void> data,
  ) {
    return _InitDartApiDL(
      data,
    );
  }

  late final _InitDartApiDLPtr =
      _lookup<ffi.NativeFunction<ffi.IntPtr Function(ffi.Pointer<ffi.Void>)>>(
          'InitDartApiDL');
  late final _InitDartApiDL =
      _InitDartApiDLPtr.asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  void Dispose() {
    return _Dispose();
  }

  late final _DisposePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dispose');
  late final _Dispose = _DisposePtr.asFunction<void Function()>();

  void OnEvent(
    ffi.Pointer<EventParam> param,
  ) {
    return _OnEvent(
      param,
    );
  }

  late final _OnEventPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<EventParam>)>>(
          'OnEvent');
  late final _OnEvent =
      _OnEventPtr.asFunction<void Function(ffi.Pointer<EventParam>)>();

  void OnEventLegacy(
    ffi.Pointer<ffi.Int8> event,
    ffi.Pointer<ffi.Int8> data,
    ffi.Pointer<ffi.Pointer<ffi.Void>> buffer,
    ffi.Pointer<ffi.Uint32> length,
    int buffer_count,
  ) {
    return _OnEventLegacy(
      event,
      data,
      buffer,
      length,
      buffer_count,
    );
  }

  late final _OnEventLegacyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Uint32>,
              ffi.Uint32)>>('OnEventLegacy');
  late final _OnEventLegacy = _OnEventLegacyPtr.asFunction<
      void Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>,
          ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.Uint32>, int)>();

  void OnEventExLegacy(
    ffi.Pointer<ffi.Int8> event,
    ffi.Pointer<ffi.Int8> data,
    ffi.Pointer<ffi.Int8> result,
    ffi.Pointer<ffi.Pointer<ffi.Void>> buffer,
    ffi.Pointer<ffi.Uint32> length,
    int buffer_count,
  ) {
    return _OnEventExLegacy(
      event,
      data,
      result,
      buffer,
      length,
      buffer_count,
    );
  }

  late final _OnEventExLegacyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Uint32>,
              ffi.Uint32)>>('OnEventExLegacy');
  late final _OnEventExLegacy = _OnEventExLegacyPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Int8>,
          ffi.Pointer<ffi.Int8>,
          ffi.Pointer<ffi.Int8>,
          ffi.Pointer<ffi.Pointer<ffi.Void>>,
          ffi.Pointer<ffi.Uint32>,
          int)>();

  void RegisterDartPort(
    int send_port,
  ) {
    return _RegisterDartPort(
      send_port,
    );
  }

  late final _RegisterDartPortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64)>>(
          'RegisterDartPort');
  late final _RegisterDartPort =
      _RegisterDartPortPtr.asFunction<void Function(int)>();

  void UnregisterDartPort(
    int send_port,
  ) {
    return _UnregisterDartPort(
      send_port,
    );
  }

  late final _UnregisterDartPortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64)>>(
          'UnregisterDartPort');
  late final _UnregisterDartPort =
      _UnregisterDartPortPtr.asFunction<void Function(int)>();

  late final addresses = _SymbolAddresses(this);

  void SetCurrentThreadAsTarget() {
    return _SetCurrentThreadAsTarget();
  }

  late final _SetCurrentThreadAsTargetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SetCurrentThreadAsTarget');
  late final _SetCurrentThreadAsTarget =
      _SetCurrentThreadAsTargetPtr.asFunction<void Function()>();

  // @Native<Void Function()>(symbol: 'SetCurrentThreadAsTarget')
  // external void setCurrentThreadAsTarget();

  ffi.Pointer<Utf8> CollectStackTraceOfTargetThread(
    ffi.Pointer<ffi.Int64> buf,
    int bufSize,
  ) {
    return _CollectStackTraceOfTargetThread(buf, bufSize);
  }

  late final _CollectStackTraceOfTargetThreadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Utf8> Function(ffi.Pointer<ffi.Int64>,
              ffi.Size)>>('CollectStackTraceOfTargetThread');
  late final _CollectStackTraceOfTargetThread =
      _CollectStackTraceOfTargetThreadPtr.asFunction<
          ffi.Pointer<Utf8> Function(ffi.Pointer<ffi.Int64>, int)>();

  /// From collect_stack.cc
  // @Native<Pointer<Utf8> Function(Pointer<Int64>, Size)>(
  //     symbol: 'CollectStackTraceOfTargetThread')
  // external Pointer<Utf8> _collectStackTraceOfTargetThread(
  //     Pointer<Int64> buf, int bufSize);

  ffi.Pointer<ffi.Void> Dlopen(
    ffi.Pointer<Utf8> path,
    int flags,
  ) {
    return _Dlopen(path, flags);
  }

  late final _DlopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<Utf8>, ffi.Int)>>('dlopen');
  late final _Dlopen = _DlopenPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<Utf8>, int)>();

  /// `void *dlopen(const char *filename, int flags);`
  ///
  /// See `man dlopen`
  // @Native<Pointer<Void> Function(Pointer<Utf8> path, Int)>(symbol: 'dlopen')
  // external Pointer<Void> _dlopen(Pointer<Utf8> path, int flags);

  int Dladdr(
    ffi.Pointer<ffi.Void> addr,
    ffi.Pointer<DlInfo> info,
  ) {
    return _dladdr(addr, info);
  }

  late final _dladdrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<DlInfo>)>>('dladdr');
  late final _dladdr = _dladdrPtr
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<DlInfo>)>();

  /// `int dladdr(const void *addr, Dl_info *info);`
  ///
  /// See `man dladdr`
  // @Native<Int Function(Pointer<Void> addr, Pointer<DlInfo>)>(symbol: 'dladdr')
  // external int _dladdr(Pointer<Void> addr, Pointer<DlInfo> info);

  NativeStack captureStackOfTargetThread() {
  return using((arena) {
    // Invoke CollectStackTrace from helper library.
    const maxStackDepth = 1024;
    final outputBuffer = arena.allocate<ffi.Int64>(ffi.sizeOf<ffi.Int64>() * maxStackDepth);
    final error = CollectStackTraceOfTargetThread(outputBuffer, maxStackDepth);
    if (error != ffi.nullptr) {
      final errorString = error.toDartString();
      malloc.free(error);
      throw StateError(errorString); // Something went wrong.
    }

    final dlInfo = arena.allocate<DlInfo>(ffi.sizeOf<DlInfo>());

    // Process stack trace: which is a sequence of hexadecimal numbers
    // separated by commas. For each frame try to locate base address
    // of the module it belongs to using |dladdr|.
    final modules = <String, NativeModule>{};
    final frames = outputBuffer
        .asTypedList(maxStackDepth)
        .takeWhile((value) => value != 0)
        .map((addr) {
      final found = Dladdr(ffi.Pointer<ffi.Void>.fromAddress(addr), dlInfo);
      if (found == 0) {
        return NativeFrame(pc: addr);
      }

      final modulePath = dlInfo.ref.fileName.toDartString();
      final module = modules[modulePath] ??= NativeModule(
        id: modules.length,
        path: modulePath,
        baseAddress: dlInfo.ref.baseAddress.address,
      );

      return NativeFrame(module: module, pc: addr);
    }).toList(growable: false);

    return NativeStack(
        frames: frames, modules: modules.values.toList(growable: false));
  });
}
}

class _SymbolAddresses {
  final NativeIrisEventBinding _library;
  _SymbolAddresses(this._library);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<EventParam>)>>
      get OnEvent => _library._OnEventPtr;
  ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Uint32>,
              ffi.Uint32)>> get OnEventLegacy => _library._OnEventLegacyPtr;
  ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Uint32>,
              ffi.Uint32)>> get OnEventExLegacy => _library._OnEventExLegacyPtr;
}

class EventParam extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> event;

  external ffi.Pointer<ffi.Int8> data;

  @ffi.Uint32()
  external int data_size;

  external ffi.Pointer<ffi.Int8> result;

  external ffi.Pointer<ffi.Pointer<ffi.Void>> buffer;

  external ffi.Pointer<ffi.Uint32> length;

  @ffi.Uint32()
  external int buffer_count;
}

// const int kBasicResultLength = 65536;
